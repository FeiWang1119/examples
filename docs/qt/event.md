# Another Look at Events

What is a spontaneous(自发的) event? Which event types can be propagated or compressed? What is the difference between posting and sending an event? When should I call `accept()` or `ignore()` on an event? If you don't know all the answers, read on!

- The Origins of Events
- Synthetic(合成的) Events(软件系统内部以程序方式或人工方式生成的事件，而不是由直接用户交互或外部因素触发的事件)
- Custom Event Types
- Event Handling and Filtering
- Accept or Ignore?

# The Origins of Events

Events can be divided into three categories based on how they are created and how they are dispatched:

- Spontaneous events are generated by the window system. They are put in a system queue and processed one after the other by the event loop.
- Posted events are generated by Qt or by the application. They are queued by Qt and processed by the event loop.
- Sent events are generated by Qt or by the application, but they are sent directly to the target object.

When we call `QApplication::exec()` at the end of our `main()` function, the application enters Qt's event loop. Conceptually, the event loop looks like this:

```c
    while (!exit_was_called) {
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
        while (!spontaneous_event_queue_is_empty) {
            process_next_spontaneous_event();
        }
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
    }
```

First, the event loop processes any posted events until the queue is empty. Then, it processes the spontaneous events until there are none left. Finally, it processes any posted events that were generated during the processing of the spontaneous events.

Sent events are not handled by the event loop. They are delivered directly to the object.

Let's see how this works in practice with paint events. When a widget is made visible for the first time, or when it's made visible after being obscured, the window system generates a (spontaneous) paint event to ask the program to redraw the widget. The event loop eventually picks up the event and dispatches it to the widget that needs to be redrawn.

Not all paint events are generated by the window system. When you call `QWidget::update()` to redraw a widget, the widget posts a paint event to itself. The paint event is queued and eventually dispatched by the event loop.

If you're impatient and can't wait for the event loop to redraw a widget, you could in theory call `paintEvent()` directly to force an immediate repaint. But in practice this isn't always possible because `paintEvent()` is a protected function. This would also bypass any existing event filter. For that reason, Qt provides a mechanism for sending events directly rather than posting them. `QWidget::repaint()` uses this mechanism to force an immediate repaint.

One advantage of posting events as opposed to sending them is that posting gives Qt the opportunity to compress them. If you call `update()` ten times in succession on the same widget without returning to the event loop, the ten events generated by update() will automatically be merged into a single event with the union of the regions specified in all their `QPaintEvents`. Compressible event types include paint events, move events, resize events, layout hint events, and language change events.

Finally, note that you can call `QApplication::sendPostedEvents()` at any time to force Qt to process an object's posted events at the time of the call.

# Synthetic Events

Qt applications can generate their own events, either of predefined types or of custom types. This is done by creating an instance of `QEvent` (or a subclass) and calling `QApplication::postEvent()` or `QApplication::sendEvent()`.

Both functions take a `QObject *` and a `QEvent *` as arguments. If you call `postEvent()`, you must create the event object using new and Qt will automatically delete it after it is processed. If you call `sendEvent()`, you must create the event on the stack. Here's an example of posting an event:

```c
    QApplication::postEvent(mainWin, new QKeyEvent(QEvent::KeyPress, Key_X, 'X', 0));
```

Here's an example of sending an event:

```c
    QKeyEvent event(QEvent::KeyPress, Key_X, 'X', 0);
    QApplication::sendEvent(mainWin, &event);
```

Qt applications rarely need to call `postEvent()` or `sendEvent()` directly because most events are generated automatically by Qt or by the window system when necessary. In most of the cases where you want to send an event, Qt includes a high-level function that does it for you (for example, `update()` and `repaint()`).

# Custom Event Types

Qt lets you create your own event types. This technique is particularly useful in multithreaded applications, as a means of communicating with the GUI thread; see Chapter 17 of C++ GUI Programming with Qt 3 (p. 359) for an example.

Custom types can also be useful in single-threaded applications, as an inter-object communication mechanism. The main reason why you would use events rather than standard function calls, or signals and slots, is that events can be used both synchronously and asynchronously (depending on whether you call `sendEvent()` or `postEvents()`), whereas calling a function or invoking a slot is always synchronous. Another advantage of events is that they can be filtered. More on this in the next section.

Here's a code snippet that shows how to post a custom event:

```c
    const QEvent::Type MyEvent = (QEvent::Type)1234;
    ...
    QApplication::postEvent(obj, new QCustomEvent(MyEvent));
```

The event must be of type `QCustomEvent` (or a subclass). The argument to the constructor is the type of event. Values under 1024 are reserved by Qt for predefined event types; other values can be used by applications.

To handle custom event types, reimplement the `customEvent()` function:

```c
    void MyLineEdit::customEvent(QCustomEvent *event)
    {
        if (event->type() == MyEvent) {
            myEvent();
        } else {
            QLineEdit::customEvent(event);
        }
    }
```

The `QCustomEvent` class has a `void *` member that you can use for your own purposes. You can also subclass `QCustomEvent` and add other members if you want more type safety---but then you also need to cast the `QCustomEvent` to your specific type in `customEvent()`.

# Event Handling and Filtering

Events in Qt can be processed on five different levels.

- Reimplementing a specific event handler.
  QObject and QWidget provide many specific event handlers for different types of events (for example, `paintEvent()` for paint events).
- Reimplementing `QObject::event()`.
  The `event()` function is the entry point for all of an object's events. The default implementations in QObject and QWidget simply forward the events to the specific event  handlers.
- Installing an event filter on a QObject.
  An event filter is an object that receives another object's events before they reach the intended target.
- Installing an event filter on qApp.
  Exceptionally, an event filter on qApp monitors all events sent to all objects in the application.
- Reimplementing `QApplication::notify()`.
  Qt's event loop and `sendEvent()` call this function to dispatch events. By reimplementing it, you get to see events before anybody else.

Some event types can be propagated. This means that if a target doesn't handle an event, Qt tries to find another receiver for the event and calls `QApplication::notify()` with the new target.
For example, key events are propagated; if the widget that has the focus doesn't handle a certain key, Qt dispatches the same event to the parent widget, then to the parent's parent, and so on until it reaches the top-level widget.

# Accept or Ignore?

Events that can be propagated have an `accept()` and an `ignore()` function that you can call to tell Qt that you "accept" or "ignore" the event. If an event handler calls `accept()` on an event, the event won't be propagated further; if an event handler calls `ignore()`, Qt tries to find another receiver.

If you're like most Qt developers, you probably never really bothered calling `accept()` and `ignore()` in your programs. And rightly so. Qt is designed in such a way that you normally never need to call them. The default value is "accept", and the default event handler implementations in QWidget call `ignore()`. If you want to accept the event, you just need to reimplement the event handler and avoid calling the QWidget implementation. If you want to ignore the event, simply pass it on to the QWidget implementation. The following code snippet illustrates the point:

```c
    void MyFancyWidget::keyPressEvent(QKeyEvent *event)
    {
        if (event->key() == Key_Escape) {
            doEscape();
        } else {
            QWidget::keyPressEvent(event);
        }
    }
```

In this example, if the user presses `Esc`, we call `doEscape()` and the event is accepted (the default). The event won't be propagated to the parent widget. If the user presses any other key, we call QWidget's default implementation:

```c
    void QWidget::keyPressEvent(QKeyEvent *event)
    {
        event->ignore();
    }
```

Thanks to the `ignore()` call, the event will be propagated to the parent widget.

So far, we've assumed that the base class is `QWidget`. However, the same idiom works at any level, by replacing `QWidget` with the base class. For example:

```c
    void MyFancyLineEdit::keyPressEvent(QKeyEvent *event)
    {
        if (event->key() == Key_SysReq) {
            doSystemRequest();
        } else {
            QLineEdit::keyPressEvent(event);
        }
    }
```

If for some reason you handle the event in `event()` instead of in a specific handler such as `keyPressEvent()`, the procedure is somewhat different. The `event()` function returns a bool that tells the caller whether the event was accepted or not (true means "accept"). Calling `accept()` or `ignore()` on an event from `event()` is pointless. The "accept" flag is a communication mechanism between the specific event handlers and `event()`, whereas the bool return value of `event()` is used to communicate with `QApplication::notify()`. The default `event()` implementation in `QWidget` converts the "accept" flag into a bool as follows:

```c
    bool QWidget::event(QEvent *event)
    {
        switch (e->type()) {
        case QEvent::KeyPress:
            keyPressEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
        case QEvent::KeyRelease:
            keyReleaseEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
            ...
        }
        return true;
    }
```
    
What has been said so far applies not only to key events but also to mouse, wheel, tablet, and context menu events.

Close events work differently. Calling `QCloseEvent::ignore()` cancels the close operation, whereas `accept()` tells Qt to continue closing the operation normally. To avoid any confusion, it's a good idea to call `accept()` or `ignore()` explicitly in your `closeEvent()` reimplementation, like this:

```c
    void MainWindow::closeEvent(QCloseEvent *event)
    {
        if (userReallyWantsToQuit()) {
            event->accept();
        } else {
            event->ignore();
        }
    }
```

# source parse

从源码中可知，Qt 先处理事件过滤器(eventFilter)，再处理event, event 把事件传递到各个事件处理函数。

```c
// qapplication: 3290

    // send to all receiver event filters
    if (sendThroughObjectEventFilters(receiver, e)) {
        filtered = true;
        return filtered;
    }

    // deliver the event
    consumed = receiver->event(e);
```

从源码中可知，事件处理函数返回false，事件会传递给父对象(parentWidget) 

```c
// qapplication: 2791
    while (w) {
        ...
        eventAccepted = (w == receiver ? mouse : &me)->isAccepted();
        if (res && eventAccepted)
            break;
        if (w->isWindow() || w->testAttribute(Qt::WA_NoMousePropagation))
            break;
        w = w->parentWidget();
    }
```
